# NLS Fine-tune SciX - Hybrid NER Pipeline

## Codebase Patterns

- **Operator Gating Rule**: Only set IntentSpec.operator when EXPLICIT patterns match ("papers citing X", "references of X"), NOT for generic words like "citing" or "references" used as topics
- **FIELD_ENUMS Validation**: All doctype/property/database/bibgroup/esources/data values MUST be validated against FIELD_ENUMS before assembly
- **Quote Multi-word Phrases**: Single-word values can be bare, multi-word phrases MUST be quoted in ADS syntax
- **No LLM for Operators**: Operators become enum decisions, not generated text. LLM only for paper reference resolution

## Project Context

This Ralph cycle implements a **hybrid NER + fine-tuned model pipeline** to replace end-to-end generation that caused malformed operators like `citations(abs:referencesabs:...)`.

**Previous approach (archived)**: End-to-end fine-tuned Qwen3-1.7B model that learned to conflate natural language words with ADS operator syntax.

**New approach**: 
1. NER extracts structured IntentSpec
2. Few-shot retrieval from gold_examples.json for pattern guidance
3. Deterministic template assembly with FIELD_ENUMS validation
4. Fine-tuned model ONLY as fallback for ambiguous paper references

## Key Learnings from Previous Iteration

- Training data quality is the root cause of malformed operators
- 7K training examples with only 4.4% operator coverage conflated NL with ADS syntax
- Post-processing filters (constrain.py) are band-aids, not solutions
- Need deterministic query building, not end-to-end generation

---

## Progress Log

(Entries will be appended below as stories are completed)

---
## 2026-01-21 - US-001: Define IntentSpec dataclass and pipeline skeleton
Thread: https://ampcode.com/threads/T-019be380-a26d-74a8-a7bf-01162d7c7510

### What was implemented
- Created `intent_spec.py` with typed IntentSpec dataclass:
  - All required fields: free_text_terms, authors, affiliations, objects, year_from, year_to
  - Enum constraint fields: doctype, property, database, bibgroup, esources, data (as set[str])
  - Operator fields: operator (validated against OPERATORS frozenset), operator_target
  - Metadata: raw_user_text, confidence dict
  - Methods: has_constraints(), has_content(), to_dict(), to_json(), from_dict(), from_json()
  - Operator validation in __post_init__

- Created `pipeline.py` with skeleton:
  - GoldExample dataclass for retrieval results
  - DebugInfo dataclass with timing fields
  - PipelineResult with intent, retrieved_examples, final_query, debug_info, success, error
  - process_query() function with placeholder implementations for each stage
  - is_ads_query() helper for detecting pre-formed ADS syntax

- Added 36 unit tests in tests/test_intent_spec.py:
  - IntentSpec instantiation, serialization, deserialization, roundtrip
  - Operator validation (valid/invalid)
  - has_constraints() and has_content() helpers
  - Pipeline returns stable keys
  - is_ads_query() detection

### Files changed
- packages/finetune/src/finetune/domains/scix/intent_spec.py (new)
- packages/finetune/src/finetune/domains/scix/pipeline.py (new)
- tests/test_intent_spec.py (new)
- prd.json (updated US-001 passes: true)

### Learnings for future iterations
- Use `X | None` instead of `Optional[X]` for type annotations (ruff UP045)
- Import order must be alphabetical within stdlib/third-party groups (ruff I001)
- Sets must be converted to sorted lists for deterministic JSON serialization
- OPERATORS frozenset prevents invalid operator values at construction time
- **Word Boundary Matching**: Always use `\b` regex boundaries for synonym extraction to avoid partial matches (e.g., "oa" falsely matching inside "sloan")

---

## 2026-01-21 - US-002: Implement rules-based NER with strict operator gating
Thread: https://ampcode.com/threads/T-019be384-fa87-76de-aa3b-e57df1c17263

### What was implemented
- Created `ner.py` with `extract_intent(text: str) -> IntentSpec` function
- Implemented strict operator gating with explicit pattern matching:
  - citations: 'papers citing', 'cited by', 'who cited'
  - references: 'references of', 'bibliography of', 'papers referenced by'
  - similar: 'similar to this paper', 'papers like'
  - trending: 'trending papers', 'what's hot'
  - useful: 'most useful'
  - reviews: 'review articles on', 'reviews of'
- Added synonym maps for all enum types:
  - PROPERTY_SYNONYMS: refereed, peer reviewed, open access, oa, arxiv, preprint
  - DOCTYPE_SYNONYMS: article, thesis, conference, software, book
  - BIBGROUP_SYNONYMS: hubble→HST, webb→JWST, sloan→SDSS, ligo→LIGO
  - DATABASE_SYNONYMS: astronomy, astrophysics, physics, general
- Year extraction patterns: from/to, since, after, before, last N years, decade
- Author extraction: by <name>, first author, et al.
- ADS query passthrough detection (skip NER for pre-formed syntax)
- Integrated into pipeline.process_query()

### Files changed
- packages/finetune/src/finetune/domains/scix/ner.py (new - 777 lines)
- packages/finetune/src/finetune/domains/scix/pipeline.py (modified - use NER)
- tests/test_ner.py (new - 75 tests)
- prd.json (updated US-002 passes: true)

### Learnings for future iterations
- **Word boundary matching is critical**: Substring matching causes false positives (e.g., "oa" in "sloan" matching openaccess synonym)
- **Author regex should not be greedy**: Avoid matching stopwords like "on" as part of author names
- **Stopwords must include "of"**: Was missing from initial stopwords set
- **Test negative cases extensively**: Operator gating requires testing both positive patterns AND ensuring generic uses don't trigger operators

---

## 2026-01-22 - US-003: Implement few-shot retrieval over gold_examples.json
Thread: https://ampcode.com/threads/T-019be38b-459d-7747-b213-ec86be101471

### What was implemented
- Created `retrieval.py` with BM25-like scoring over 4002 gold examples
- `GoldExampleIndex` class for preloading and indexing examples at startup:
  - Tokenization with stopword removal
  - IDF computation for BM25 scoring
  - Feature extraction from ADS queries (operators, doctypes, properties, etc.)
- `retrieve_similar(intent: IntentSpec, k: int = 5) -> list[GoldExample]` main entry point
- Feature-based boosting:
  - +5.0 for exact operator match
  - +2.0 for author presence match
  - +1.5 for year/pubdate presence match
  - +1.5 per matching doctype/property/bibgroup/database
  - +1.0 for category match (operator, author, property categories)
- Singleton pattern for global index to avoid reloading on every request
- Performance: avg 0.5ms per retrieval (well under 20ms target)
- Integrated into pipeline.process_query() Stage 2

### Files changed
- packages/finetune/src/finetune/domains/scix/retrieval.py (new - 350 lines)
- packages/finetune/src/finetune/domains/scix/pipeline.py (modified - integrated retrieval)
- tests/test_retrieval.py (new - 29 tests)
- prd.json (updated US-003 passes: true)

### Learnings for future iterations
- **BM25 IDF formula matters**: Using `log((N - df + 0.5) / (df + 0.5) + 1)` for proper term weighting
- **Feature boosting > pure token overlap**: Matching structural features (operators, doctypes) is more important than word similarity for ADS queries
- **Precompute everything possible**: Tokenization and IDF at index load time keeps retrieval fast
- **Singleton with reset for testing**: Global index pattern with `reset_index()` enables test isolation

---

## 2026-01-22 - US-004: Implement deterministic template assembler
Thread: https://ampcode.com/threads/T-019be38e-d572-7067-b3aa-69ad38bf950b

### What was implemented
- Created `assembler.py` with deterministic query assembly from IntentSpec:
  - `assemble_query(intent, examples)` - main entry point
  - `_build_author_clause()` - formats authors as `author:"Last, F"`
  - `_build_abs_clause()` - handles topics with proper quoting
  - `_build_year_clause()` - creates `pubdate:[YYYY TO YYYY]` ranges
  - `_build_object_clause()` - astronomical object formatting
  - `_build_affiliation_clause()` - institution formatting
  - `_build_enum_clause()` - enum-constrained fields (doctype, property, etc.)
  - `_wrap_with_operator()` - wraps query with citations/references/etc.
  - `_validate_enum_values()` - validates against FIELD_ENUMS
  - `validate_query_syntax()` - checks for malformed patterns
- Integrated assembler into pipeline.py Stage 3
- Added 73 unit tests covering:
  - Quoting logic (single-word vs multi-word)
  - Enum validation (valid/invalid values)
  - Individual clause building
  - Operator wrapping
  - Full assembly with complex intents
  - Syntax validation
  - Fuzz tests for malformed operator prevention

### Files changed
- packages/finetune/src/finetune/domains/scix/assembler.py (new - 320 lines)
- packages/finetune/src/finetune/domains/scix/pipeline.py (modified - integrated assembler)
- packages/finetune/src/finetune/domains/scix/retrieval.py (reformatted by linter)
- tests/test_assembler.py (new - 73 tests)
- prd.json (updated US-004 passes: true)

### Learnings for future iterations
- **Quote all author names**: Always use `author:"Name"` syntax since names often contain commas
- **Enum case canonicalization**: FIELD_ENUMS uses canonical casing, need to match against lowercase and return canonical
- **Fuzz testing critical**: Random insertion of operator words ("citations", "references") must never produce malformed concatenations
- **Validation fallback**: If >50% of constraints are dropped, fall back to simpler query
- **constrain_query_output() as safety net**: Run existing constraint filter as final step

---

## 2026-01-22 - US-005: Implement optional LLM resolver for ambiguous paper references
Thread: https://ampcode.com/threads/T-019be392-f26d-71eb-8906-3f5967bddac7

### What was implemented
- Created `resolver.py` with optional LLM paper reference resolution:
  - `needs_resolution()` - Gating function that returns True ONLY when:
    - Operator is citations/references/similar (requires target)
    - No explicit target bibcode provided
    - Text contains ambiguous patterns ("this paper", "famous paper", etc.)
  - `extract_paper_hint()` - Extracts topic/author/year hints from user text
  - `resolve_via_ads_search()` - Deterministic resolution via ADS (most-cited match)
  - `resolve_via_llm()` - Fallback LLM call with 300ms timeout
  - `resolve_paper_reference()` - Main entry point orchestrating resolution
- ResolverResult dataclass with: success, bibcode, paper_title, fallback_reason, timing
- OPERATORS_REQUIRING_TARGET = {citations, references, similar}
- AMBIGUOUS_REFERENCE_PATTERNS = 11 patterns for detecting ambiguous refs

### Files changed
- packages/finetune/src/finetune/domains/scix/resolver.py (new - 330 lines)
- tests/test_resolver.py (new - 52 tests)
- prd.json (updated US-005 passes: true)

### Learnings for future iterations
- **Gating is critical**: LLM should ONLY be called for specific conditions (operator + ambiguous ref)
- **Two-stage resolution**: Try ADS search from hint first, LLM only as fallback
- **Deterministic bibcode selection**: Sort by citation_count desc ensures reproducible results
- **Mock both httpx.get and httpx.post**: ADS uses GET, OpenAI uses POST
- **Normal queries must never trigger LLM**: Extensive negative test cases validate this

---

## 2026-01-22 - US-009: Regression test suite for known failure patterns
Thread: https://ampcode.com/threads/T-019be395-dcf2-765f-b1b4-b518cd8e8bc4

### What was implemented
- Created `tests/regression/test_operator_conflation.py` with 63 comprehensive tests
- Test classes covering all acceptance criteria:
  - `TestOperatorConflationRegression`: 20 tests for operator word gating
    - Operator words as topics (citing, references, etc.) don't trigger operators
    - Explicit operator patterns (papers citing X) DO trigger operators correctly
  - `TestMalformedConcatenationPatterns`: 10 tests for known failure inputs
    - Ensures no `citationsabs:`, `referencesabs:` patterns ever appear
  - `TestNestedOperatorEdgeCases`: 4 tests for nested operator requests
    - Graceful handling (single operator or no operator output)
  - `TestEmptyAndPassthroughInputs`: 6 tests for edge cases
    - Empty/whitespace input produces valid (possibly empty) response
    - Already-ADS-syntax input passes through with validation
  - `TestEnumValueValidation`: 8 tests for FIELD_ENUMS validation
    - All doctype/property/database/bibgroup values in output are valid
  - `TestParenthesesBalance`: 5 tests for parentheses balancing
    - Inputs containing parentheses produce balanced output
  - `TestKnownFailureStrings`: 10 tests for known failure strings
    - 9 known failure patterns that should NEVER appear in output
- Helper functions for pattern checking: `check_no_malformed_patterns()`, `check_balanced_parentheses()`, `check_enum_values()`
- All 63 tests pass

### Files changed
- tests/regression/__init__.py (new - package init)
- tests/regression/test_operator_conflation.py (new - 380 lines, 63 tests)
- prd.json (updated US-009 passes: true)

### Learnings for future iterations
- **Parametrized tests are powerful**: Using `@pytest.mark.parametrize` allows testing many inputs with single test logic
- **Negative pattern matching**: Using regex to detect malformed patterns is more robust than substring matching
- **Known failure strings list**: Maintaining an explicit list of known failures ensures they never regress
- **Test the pipeline end-to-end**: These regression tests call `process_query()` directly, validating the full pipeline
- **Separate concerns**: Different test classes for different failure categories makes maintenance easier

---

## 2026-01-22 - US-006: Integrate pipeline into Nectar API endpoint
Thread: https://ampcode.com/threads/T-019be398-4d8d-7495-82e7-af35615da979

### What was implemented
- Created `serve_pipeline.py` in packages/finetune/src/finetune/modal/ with:
  - `PipelineServer` Modal class with preloaded gold_examples index
  - `/query` endpoint for direct pipeline calls  
  - `/v1/chat/completions` OpenAI-compatible endpoint for drop-in replacement
  - CPU-only deployment (deterministic pipeline, no GPU needed)
  - Warm latency target: <200ms

- Updated `~/ads-dev/nectar/src/pages/api/nl-search.ts` with:
  - `PIPELINE_ENDPOINT` constant pointing to new Modal endpoint
  - TypeScript types: `PipelineDebugInfo`, `PipelineRetrievedExample`, `PipelineResult`, `PipelineChatResponse`
  - `callPipeline()` helper with 2s timeout
  - `callVLLM()` fallback helper
  - Handler logic: try pipeline first, fall back to vLLM on failure
  - Skip operator post-processing when pipeline used (pipeline handles correctly)
  - Return `pipelineDebug` in response with intent, examples, timing, corrections
  - Added `usePipeline` request option (default: true)

### Files changed
- packages/finetune/src/finetune/modal/serve_pipeline.py (new - 275 lines)
- ~/ads-dev/nectar/src/pages/api/nl-search.ts (modified - +216, -37 lines)
- prd.json (updated US-006 passes: true)

### Learnings for future iterations
- **OpenAI-compatible endpoints ease integration**: Using chat completions format allows drop-in replacement with minimal API changes
- **Pipeline-first with fallback**: Always try deterministic pipeline first; LLM-based endpoint is fallback
- **Timeout handling is critical**: Pipeline should respond quickly; 2s timeout catches cold starts
- **Skip redundant post-processing**: When pipeline used, operator post-processing is redundant (and could conflict)
- **Debug info enables observability**: Returning timing/intent/examples helps monitor pipeline quality in production

---

## 2026-01-22 - US-007: Deploy pipeline to Modal with preloaded indexes
Thread: https://ampcode.com/threads/T-019be39d-72b6-72ff-9f55-b23400d24e77

### What was implemented
- Updated `serve_pipeline.py` with Modal deployment configuration:
  - Added `add_local_dir` (replacing deprecated `copy_local_dir`) to copy finetune package
  - Updated to `fastapi_endpoint` (replacing deprecated `web_endpoint`)
  - Added `fastapi` and `httpx` to pip dependencies
  - Removed custom `__init__` (deprecated) in favor of class attributes
- Created `/v1/query` endpoint as specified in acceptance criteria:
  - Accepts `{"nl_text": "..."}` JSON body
  - Returns `{query, intent, retrieved_examples, debug_info, success}`
- Preloading at container startup (`@modal.enter()`):
  - FIELD_ENUMS for constraint validation
  - NER synonym maps (PROPERTY_SYNONYMS, DOCTYPE_SYNONYMS, etc.)
  - Retrieval index via `get_index()` with gold_examples.json from Modal volume
- Added `GOLD_EXAMPLES_PATH` environment variable support in `retrieval.py`
- Added `num_examples` property to `GoldExampleIndex` for monitoring
- Uploaded gold_examples.json to Modal volume `nls-query-data`
- Verified deployment with 3 curl tests:
  - Test 1: `papers about exoplanets` → 767ms (cold), 220ms (warm)
  - Test 2: `refereed papers on dark matter since 2020` → 220ms (warm)
  - Test 3: `papers citing Hawking radiation paper` → 271ms (warm)

### Endpoints deployed
- `/v1/query`: https://sjarmak--v1-query.modal.run
- `/v1/chat/completions`: https://sjarmak--v1-chat-completions.modal.run
- `/query`: https://sjarmak--nls-finetune-pipeline-query.modal.run

### Files changed
- packages/finetune/src/finetune/modal/serve_pipeline.py (modified - +160, -40 lines)
- packages/finetune/src/finetune/domains/scix/retrieval.py (modified - +17, -8 lines)
- packages/finetune/src/finetune/domains/scix/resolver.py (reformatted)
- prd.json (updated US-007 passes: true)

### Learnings for future iterations
- **Modal API changed**: Use `add_local_dir` instead of deprecated `copy_local_dir`, `fastapi_endpoint` instead of `web_endpoint`
- **Modal images need fastapi**: Web endpoints now require explicit `fastapi` pip install
- **Environment variables for paths**: Use `os.environ.get("GOLD_EXAMPLES_PATH")` pattern to allow runtime override for Modal volumes
- **Cold start vs warm latency**: First request may take 700-800ms (index loading), subsequent requests ~20ms (well under 200ms target)
- **httpx required**: The resolver module imports httpx, so must be installed even if LLM fallback is rarely used

### Deployment timestamp
2026-01-22 02:55 EST

---
